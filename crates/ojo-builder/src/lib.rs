use fnv::FnvHasher;
use std::{collections::HashSet, env, fs::File, hash::Hasher, io::Write, path::Path};

/// Value type for event payload - must match ojo_client::ValueType
#[derive(Clone, Copy, Debug, PartialEq, Eq, Default)]
pub enum ValueType {
    #[default]
    None,
    Identifier,
    Count,
    Bytes,
    Duration,
    RangeCount,
    RangeBytes,
    RangeDuration,
}

#[derive(Clone, Debug)]
pub struct EventInfo {
    pub name: String,
    pub category: String,
    pub description: String,
    pub value_type: ValueType,
}

#[derive(Clone, Debug, Default)]
pub struct Builder {
    events: Vec<EventInfo>,
}

impl Builder {
    pub const fn new() -> Self {
        Self { events: Vec::new() }
    }

    pub fn add_event(mut self, event: EventInfo) -> Self {
        self.events.push(event);
        self
    }

    pub fn generate(mut self, name: &str) {
        let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
        let dest_path = Path::new(&out_dir).join(name).with_extension("rs");
        let mut f = File::create(&dest_path).expect("Failed to create output file");

        self.events.sort_by(|a, b| a.name.cmp(&b.name));

        // Validate duplicates
        let mut seen_names = HashSet::new();
        for event in &self.events {
            if !seen_names.insert(&event.name) {
                panic!("Duplicate event name: {}", event.name);
            }
        }

        // Calculate namespace hash
        let mut hasher = FnvHasher::with_key(42);
        for event in &self.events {
            hasher.write(event.name.as_bytes());
        }
        let namespace = hasher.finish();
        let namespace = namespace as u32;

        macro_rules! w {
            ($($arg:tt)*) => {
                writeln!(f, $($arg)*).unwrap();
            };
        }

        // Generate Rust code
        w!("/// Event type constants");
        w!("/// Generated by ojo-builder");
        w!("use ojo_client::{{EventTypeInfo, Schema, ValueType}};");
        w!();

        for (i, event) in self.events.iter().enumerate() {
            let id = ((namespace as u64) << 32) | (i as u64);
            for line in event.description.lines() {
                w!("/// {}", line);
            }
            w!(
                "pub const {}: u64 = 0x{:016X};",
                event.name.to_uppercase(),
                id
            );
        }

        w!("/// Event schema");
        w!("pub static SCHEMA: Schema = Schema {{");
        w!("    module: module_path!(),");
        w!("    namespace: 0x{namespace:08X},");
        w!("    events: &[");
        for (i, event) in self.events.iter().enumerate() {
            let id = ((namespace as u64) << 32) | (i as u64);
            let value_type_str = match event.value_type {
                ValueType::None => "ValueType::None",
                ValueType::Identifier => "ValueType::Identifier",
                ValueType::Count => "ValueType::Count",
                ValueType::Bytes => "ValueType::Bytes",
                ValueType::Duration => "ValueType::Duration",
                ValueType::RangeCount => "ValueType::RangeCount",
                ValueType::RangeBytes => "ValueType::RangeBytes",
                ValueType::RangeDuration => "ValueType::RangeDuration",
            };
            w!("        EventTypeInfo {{");
            w!("            value: 0x{id:016X},");
            w!("            name: \"{}\",", event.name);
            w!("            category: \"{}\",", event.category);
            w!("            description: \"{}\",", event.description);
            w!("            value_type: {},", value_type_str);
            w!("        }},");
        }
        w!("    ],");
        w!("}};");
    }
}
