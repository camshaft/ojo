use std::env;
use std::fs::File;
use std::io::Write;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("event_types.rs");
    let mut f = File::create(&dest_path).unwrap();

    // Schema version - increment when changing event types
    let schema_version: u64 = 1;

    // Define event types with their metadata
    let events = [
        // Packet events (0x00000001 - 0x000000FF)
        (0x00000001u64, "PACKET_CREATED", "Packet", "Packet created"),
        (0x00000002u64, "PACKET_SENT", "Packet", "Packet sent"),
        (
            0x00000003u64,
            "PACKET_ACKED",
            "Packet",
            "Packet acknowledged",
        ),
        (
            0x00000004u64,
            "PACKET_LOST_TIMEOUT",
            "Packet",
            "Packet lost due to timeout",
        ),
        (
            0x00000005u64,
            "PACKET_LOST_DUPLICATE_ACK",
            "Packet",
            "Packet lost due to duplicate ACK",
        ),
        (
            0x00000006u64,
            "PACKET_RETRANSMIT_OLD",
            "Packet",
            "Packet retransmit (old packet number)",
        ),
        (
            0x00000007u64,
            "PACKET_RETRANSMIT_NEW",
            "Packet",
            "Packet retransmit (new packet number)",
        ),
        // Stream events (0x00000100 - 0x000001FF)
        (0x00000100u64, "STREAM_OPENED", "Stream", "Stream opened"),
        (
            0x00000101u64,
            "STREAM_LINK_PARENT",
            "Stream",
            "Stream link to parent connection",
        ),
        (
            0x00000102u64,
            "STREAM_FIN_SENT",
            "Stream",
            "Stream FIN sent",
        ),
        (
            0x00000103u64,
            "STREAM_FIN_ACKED",
            "Stream",
            "Stream FIN acknowledged",
        ),
        // Flow control events (0x00000200 - 0x000002FF)
        (
            0x00000200u64,
            "CONNECTION_MAX_DATA_UPDATE",
            "FlowControl",
            "Connection max data update",
        ),
        (
            0x00000201u64,
            "STREAM_MAX_DATA_UPDATE",
            "FlowControl",
            "Stream max data update",
        ),
        // Congestion control events (0x00000300 - 0x000003FF)
        (
            0x00000300u64,
            "CWND_UPDATED",
            "CongestionControl",
            "Congestion window updated",
        ),
        (
            0x00000301u64,
            "SSTHRESH_UPDATED",
            "CongestionControl",
            "Slow start threshold updated",
        ),
        // Meta events (0x0000FF00 - 0x0000FFFF)
        (
            0x0000FF01u64,
            "EVENTS_DROPPED",
            "Meta",
            "Events dropped due to buffer overflow",
        ),
    ];

    // Check for duplicates
    let mut seen_values = std::collections::HashSet::new();
    let mut seen_names = std::collections::HashSet::new();
    for (value, name, _, _) in &events {
        if !seen_values.insert(value) {
            panic!("Duplicate event type value: 0x{:08X}", value);
        }
        if !seen_names.insert(name) {
            panic!("Duplicate event type name: {}", name);
        }
    }

    // Generate JSON schema file
    let schema_json = generate_schema_json(&out_dir, schema_version, &events);

    // Generate the module
    writeln!(f, "/// Event type constants").unwrap();
    writeln!(f, "///").unwrap();
    writeln!(
        f,
        "/// This module is generated by build.rs to ensure uniqueness"
    )
    .unwrap();
    writeln!(f, "/// and provide reflection capabilities.").unwrap();
    writeln!(f, "pub mod event_type {{").unwrap();
    writeln!(f, "    use super::EventTypeInfo;").unwrap();
    writeln!(f).unwrap();
    
    // Add schema version constant
    writeln!(f, "    /// Schema version for event types").unwrap();
    writeln!(f, "    pub const SCHEMA_VERSION: u64 = {};", schema_version).unwrap();
    writeln!(f).unwrap();
    
    // Add schema JSON constant
    writeln!(f, "    /// Event schema JSON").unwrap();
    writeln!(f, "    pub const SCHEMA_JSON: &str = r###\"{}\"###;", schema_json).unwrap();
    writeln!(f).unwrap();

    // Generate constants
    for (value, name, _, description) in &events {
        writeln!(f, "    /// {}", description).unwrap();
        writeln!(f, "    pub const {}: u64 = 0x{:08X};", name, value).unwrap();
        writeln!(f).unwrap();
    }

    // Generate metadata array
    writeln!(f, "    /// Metadata for all event types").unwrap();
    writeln!(f, "    pub const ALL_EVENTS: &[EventTypeInfo] = &[").unwrap();
    for (value, name, category, description) in &events {
        writeln!(f, "        EventTypeInfo {{").unwrap();
        writeln!(f, "            value: 0x{:08X},", value).unwrap();
        writeln!(f, "            name: \"{}\",", name).unwrap();
        writeln!(f, "            category: \"{}\",", category).unwrap();
        writeln!(f, "            description: \"{}\",", description).unwrap();
        writeln!(f, "        }},").unwrap();
    }
    writeln!(f, "    ];").unwrap();
    writeln!(f, "}}").unwrap();

    println!("cargo:rerun-if-changed=build.rs");
}

fn generate_schema_json(
    out_dir: &str,
    schema_version: u64,
    events: &[(u64, &str, &str, &str)],
) -> String {
    let schema_path = Path::new(out_dir).join("event_schema.json");

    // Create JSON schema structure
    let mut schema_json = String::new();
    schema_json.push_str("{\n");
    schema_json.push_str(&format!("  \"schema_version\": {},\n", schema_version));
    schema_json.push_str("  \"events\": [\n");

    for (i, (value, name, category, description)) in events.iter().enumerate() {
        schema_json.push_str("    {\n");
        schema_json.push_str(&format!("      \"value\": {},\n", value));
        schema_json.push_str(&format!("      \"name\": \"{}\",\n", name));
        schema_json.push_str(&format!("      \"category\": \"{}\",\n", category));
        schema_json.push_str(&format!("      \"description\": \"{}\"\n", description));
        if i < events.len() - 1 {
            schema_json.push_str("    },\n");
        } else {
            schema_json.push_str("    }\n");
        }
    }

    schema_json.push_str("  ]\n");
    schema_json.push_str("}\n");

    // Write to file
    let mut schema_file = File::create(&schema_path).unwrap();
    write!(schema_file, "{}", schema_json).unwrap();

    schema_json
}
